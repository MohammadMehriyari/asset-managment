import datetime
import json
import logging
import uuid
# from django.contrib.auth import update_session_auth_hash
from django.contrib.auth.hashers import make_password
from django.core.validators import RegexValidator
from django.db import connection
from rest_framework import serializers
from rest_framework_simplejwt.token_blacklist.models import OutstandingToken
from django.utils import timezone
from .models import User, Area, Building, Userrole, Userlocationinbuildingarea
from django.contrib import auth
from rest_framework.exceptions import AuthenticationFailed
from rest_framework_simplejwt.tokens import RefreshToken, TokenError
from assetManagementSystem import settings

logger = logging.getLogger(__name__)


class LoginSerializer(serializers.ModelSerializer):
    # for login we need password and personal id, the tokens will be generated by get_tokens method

    userpersonalid = serializers.IntegerField()
    userpasword = serializers.CharField(max_length=128, min_length=8, write_only=True)
    tokens = serializers.SerializerMethodField()
    userroleid = serializers.IntegerField(read_only=True)

    def get_tokens(self, obj):
        user = User.objects.get(userpersonalid=obj['userpersonalid'])
        return {
            'refresh': user.tokens()['refresh'],
            'access': user.tokens()['access'],
        }

    class Meta:
        model = User
        fields = ['userid', 'userpersonalid', 'userroleid', 'userpasword', 'tokens']

    def validate(self, attrs):
        userpersonalid = attrs.get('userpersonalid', '')
        userpasword = attrs.get('userpasword', '')
        user = auth.authenticate(personalId=userpersonalid, password=userpasword)

        # if any of the userpersonalid, userpasword be wrong will go inside this if
        if not user:
            raise AuthenticationFailed('invalid credentials, try again')
        elif user:

            # we save the expired time of access token
            outstandtoken = OutstandingToken(user=user, expires_at=timezone.now() + settings.SIMPLE_JWT.get(
                'ACCESS_TOKEN_LIFETIME'))
            outstandtoken.jti = uuid.uuid4()
            outstandtoken.save()

            user.last_login = timezone.now()
            user.is_authenticated = True
            user.is_anonymous = False
            user.save()

            # this field will be return
            return {
                'userpersonalid': user.userpersonalid,
                'userid': user.userid,
                'userroleid': user.userroleid.userroleid,
                'tokens': user.tokens
            }


class LogoutSerializer(serializers.Serializer):
    refresh = serializers.CharField()

    def validate(self, attrs):
        self.attrs = attrs
        self.refresh = attrs['refresh']
        return attrs

    def save(self, **kwargs):
        try:
            # we add the refresh token to the black list that can not be used again
            RefreshToken(self.refresh).blacklist()
            self.refresh = self.attrs['refresh']
            request = self.context.get("request")
            user = request.user
            user.is_authenticated = False
            user.is_anonymous = True
            user.save()
        except TokenError:
            raise ValueError('refresh token is invalid')


class ChangePasswordSerializer(serializers.Serializer):
    old_password = serializers.CharField(max_length=128, min_length=8, write_only=True, required=True)

    new_password = serializers.CharField(max_length=128, min_length=8, write_only=True, required=True)
    repeated_new_password = serializers.CharField(max_length=128, min_length=8, write_only=True, required=True)

    def validate(self, attrs):
        request = self.context.get("request")
        user = request.user
        old_password = attrs.get('old_password')
        new_password = attrs.get('new_password')
        repeated_new_password = attrs.get('repeated_new_password')

        # we check that the old password be correct
        user = auth.authenticate(personalId=user.userpersonalid, password=old_password)
        if not user:
            raise serializers.ValidationError('the entered password is incorrect')
        else:
            # check that the new passwork with repeated_new_password be same
            if new_password != repeated_new_password:
                raise serializers.ValidationError('your password and repeated password must be same!')
            # if be same
            else:
                # hash the password
                password = make_password(new_password)
                query = f"UPDATE user SET userpasword = %s WHERE userpersonalid = %s"
                with connection.cursor() as cur:
                    x = cur.execute(query, [password, user.userpersonalid])
                query = f"UPDATE auth_user SET userpasword = %s WHERE userid = %s"
                with connection.cursor() as cursor:
                    y = cursor.execute(query, [password, user.userid])

                # our change password will be write in the log file
                log_data = {
                    'action': 'change password', 'user-id': user.userid, 'changer-user-id': user.userid,
                    "timestamp": user.last_login.isoformat()
                }
                logger.info(json.dumps(log_data))
                return attrs


class CreatUserSerializer(serializers.Serializer):
    userpersonalid = serializers.IntegerField()
    username = serializers.CharField(max_length=255)
    userlastname = serializers.CharField(max_length=255)
    userphonenumber = serializers.CharField(max_length=11
                                            )
    userlandlinephonenumber = serializers.CharField(max_length=11, required=False)
    userroleid = serializers.IntegerField(min_value=2, max_value=3)
    supporterid = serializers.IntegerField(required=False)

    def validate(self, attrs):
        request = self.context.get("request")
        self.user = request.user
        self.userpersonalid = attrs.get('userpersonalid', '')
        self.username = attrs.get('username', '')
        self.userlastname = attrs.get('userlastname', '')
        self.userphonenumber = attrs.get('userphonenumber', '')
        self.userlandlinephonenumber = attrs.get('userlandlinephonenumber', '')
        self.userpasword = make_password(str(self.userphonenumber))
        self.userroleid = attrs.get('userroleid', '')
        self.supporterid = attrs.get('supporterid', '')

        # if user with this personal id exists will raise the below error
        if User.objects.filter(userpersonalid=self.userpersonalid):
            raise serializers.ValidationError(detail='user with this id already exists!')

        # if user be admin
        if self.user.userroleid.userroleid == 1:
            # if admin want to create usual just in that case user must have entered the supporter id
            if self.userroleid == 3 and self.supporterid == '':
                raise serializers.ValidationError("you have to enter the supporter id")
            # the admin just can add 2 -> supporter user , 3 -> usual user
            if self.userroleid != 2 and self.userroleid != 3:
                raise serializers.ValidationError('the id of role is not valid')

        # if user be supporter
        elif self.user.userroleid.userroleid == 2:
            # this user only can create the usual user
            if self.userroleid != 3:
                raise serializers.ValidationError('the id of role is not valid')
            self.supporterid = self.user.userid

        # if we create the usual user we have to fill userlandlinephonenumber field
        if self.userroleid != 2 and not self.userphonenumber:
            raise serializers.ValidationError('you have to enter user phone number')

        return attrs

    def save(self):
        print(self.supporterid)
        if self.supporterid != '':
            query = "INSERT INTO user (userpersonalid, username, userlastname, userphonenumber, userlandlinephonenumber, createruserid,UserSupportId, userpasword, userroleid, is_active, is_anonymous, is_authenticated) VALUES (%s, %s,%s, %s,%s, %s, %s, %s, %s, %s, %s, %s)"
            with connection.cursor() as cursor:
                cursor.execute(query, [self.userpersonalid, self.username, self.userlastname, self.userphonenumber,
                                       self.userlandlinephonenumber, self.user.userid, self.supporterid,
                                       self.userpasword, self.userroleid, True, True, False])
        else:
            query = "INSERT INTO user (userpersonalid, username, userlastname, userphonenumber, userlandlinephonenumber, createruserid, userpasword, userroleid, is_active, is_anonymous, is_authenticated) VALUES (%s, %s,%s, %s,%s, %s, %s, %s, %s, %s,%s)"
            with connection.cursor() as cursor:
                cursor.execute(query, [self.userpersonalid, self.username, self.userlastname, self.userphonenumber,
                                       self.userlandlinephonenumber, self.user.userid,
                                       self.userpasword, self.userroleid, True, True, False])
        cursor.close()


class WorkingLoactionSerializer(serializers.Serializer):
    userpersonalid = serializers.IntegerField()
    areaId = serializers.IntegerField()
    buildingId = serializers.IntegerField()
    userofficial = serializers.CharField(max_length=255)
    roomnumber = serializers.IntegerField()

    def validate(self, attrs):
        request = self.context.get("request")
        user = request.user
        self.userpersonalid = attrs.get('userpersonalid', '')
        self.areaId = attrs.get('areaId', '')
        self.buildingId = attrs.get('buildingId', '')
        self.userofficial = attrs.get('userofficial', '')
        self.roomnumber = attrs.get('roomnumber', '')

        try:
            # check that the entered areaid is exist in the tabel
            query = "select * from area where areaid = %s"
            with connection.cursor() as cursor:
                cursor.execute(query, [self.areaId])
        except:
            raise serializers.ValidationError('entered area id not in the area table')

        # if our user be the supporter
        if request.user.userroleid.userroleid == 2:
            # if entered the areaid and bulding id , doesn't work he can not add the user for this building and area
            query = """SELECT user.userid,        userlocationinbuildingarea.areaid,        userlocationinbuildingarea.buildingid FROM `user` INNER JOIN userlocationinbuildingarea ON `user`.UserId = userlocationinbuildingarea.UserId WHERE user.userpersonalid = %s; """
            with connection.cursor() as cursor:
                cursor.execute(query, [user.userpersonalid])
            self.user = cursor.fetchone()
            if self.user[1] != self.areaId or self.user[2] != self.buildingId:
                raise serializers.ValidationError('supporter user just can add user to you area and building')

        return attrs

    def save(self):
        print(self.roomnumber)
        # we get the userid by fetching it by userPersonalId becouse our Userlocationinbuildingarea accept the userId
        query = 'select userid, userroleid from user where userpersonalid = %s'
        with connection.cursor() as cur:
            cur.execute(query, [self.userpersonalid])
            userid = cur.fetchone()[0]
        cur.close()

        query = 'insert into userlocationinbuildingarea (buildingid,userid,areaid,userofficial,roomnumber) VALUES (%s, %s,%s, %s,%s)'
        connection.cursor().execute(query, [self.buildingId, userid, self.areaId, self.userofficial, self.roomnumber])


class DeleteWorkingLocationSerializer(serializers.Serializer):
    userpersonalid = serializers.IntegerField()  # Field name made lowercase.
    areaId = serializers.IntegerField()
    buildingId = serializers.IntegerField()

    def validate(self, attrs):
        self.userpersonalid = attrs.get('userpersonalid', '')
        self.areaId = attrs.get('areaId', '')
        self.buildingId = attrs.get('buildingId', '')

        query = 'select userid, userroleid from user where userpersonalid = %s'
        with connection.cursor() as cur:
            cur.execute(query, [self.userpersonalid])
            userid = cur.fetchone()[0]
        cur.close()

        query = 'delete from userlocationinbuildingarea where userid = %s and areaId = %s and buildingId = %s'
        connection.cursor().execute(query, [userid, self.areaId, self.buildingId])

        return attrs


class DetailWorkingLocationSerializer(serializers.ModelSerializer):
    class Meta:
        model = Userlocationinbuildingarea
        fields = ['buildingid',
                  'userid',
                  'areaid',
                  'userofficial',
                  'roomnumber', ]


class UpdateWorkingLocationSerializer(serializers.Serializer):
    userpersonalid = serializers.IntegerField()  # Field name made lowercase.
    areaId = serializers.IntegerField(required=False)
    buildingId = serializers.IntegerField(required=False)
    userofficial = serializers.CharField(max_length=255, required=False)
    roomnumber = serializers.IntegerField(required=False)

    def validate(self, attrs):
        request = self.context.get("request")
        self.userpersonalid = attrs.get('userpersonalid', '')
        self.areaId = attrs.get('areaId', '')
        self.buildingId = attrs.get('buildingId', '')
        self.userofficial = attrs.get('userofficial', '')
        self.roomnumber = attrs.get('roomnumber', '')

        if request.user.userroleid.userroleid == 2:
            query = """SELECT user.userid, userlocationinbuildingarea.areaid, userlocationinbuildingarea.buildingid 
                       FROM `user` 
                       INNER JOIN userlocationinbuildingarea ON `user`.UserId = userlocationinbuildingarea.UserId 
                       WHERE user.userpersonalid = %s;"""
            with connection.cursor() as cursor:
                cursor.execute(query, [request.user.userpersonalid])
            self.user = cursor.fetchone()
            if self.user[1] != self.areaId or self.user[2] != self.buildingId:
                raise serializers.ValidationError('Supporter user can only add user to their area and building.')

        query = 'SELECT userid FROM user WHERE userpersonalid = %s'
        with connection.cursor() as cur:
            cur.execute(query, [self.userpersonalid])
        userid = cur.fetchone()[0]

        update_fields = []
        update_values = []

        if self.userofficial:
            update_fields.append("userofficial = %s")
            update_values.append(self.userofficial)
        if self.roomnumber:
            update_fields.append("roomnumber = %s")
            update_values.append(self.roomnumber)
        if self.areaId:
            update_fields.append("areaId = %s")
            update_values.append(self.areaId)
        if self.buildingId:
            update_fields.append("buildingId = %s")
            update_values.append(self.buildingId)

        if update_fields:
            update_query = f"UPDATE userlocationinbuildingarea SET {', '.join(update_fields)} WHERE userid = %s"
            update_values.append(userid)
            with connection.cursor() as cursor:
                cursor.execute(update_query, update_values)

        return attrs


class DeactivateUserSerializer(serializers.Serializer):
    userpersonalid = serializers.IntegerField()

    def validate(self, attrs):
        request = self.context.get("request")
        user = request.user
        userpersonalid = attrs.get('userpersonalid', '')

        query = 'select * from user where userpersonalid = %s'
        with connection.cursor() as cursor:
            cursor.execute(query, [userpersonalid])
        changed_user = cursor.fetchone()
        changed_userid = changed_user[0]

        query = f"UPDATE user SET is_active = %s WHERE userid = %s"
        with connection.cursor() as cur:
            cur.execute(query, [False, changed_userid])

        user = self.context.get("request").user

        log_data = {
            'action': 'deactivated user', 'user-id': changed_userid, 'changer-user-id': user.userid,
            "timestamp": timezone.now().isoformat()
        }
        logger.info(json.dumps(log_data))

        return attrs


class activateUserSerializer(serializers.Serializer):
    userpersonalid = serializers.IntegerField()

    def validate(self, attrs):
        request = self.context.get("request")
        user = request.user
        userpersonalid = attrs.get('userpersonalid', '')

        query = 'select * from user where userpersonalid = %s'
        with connection.cursor() as cursor:
            cursor.execute(query, [userpersonalid])
        changed_user = cursor.fetchone()
        changed_userid = changed_user[0]

        query = f"UPDATE user SET is_active = %s WHERE userid = %s"
        with connection.cursor() as cur:
            cur.execute(query, [True, changed_userid])

        user = self.context.get("request").user

        log_data = {
            'action': 'activated user', 'user-id': changed_userid, 'changer-user-id': user.userid,
            "timestamp": timezone.now().isoformat()
        }
        logger.info(json.dumps(log_data))

        return attrs


class ChangeSubUserPasswordSerializer(serializers.Serializer):
    userpersonalid = serializers.IntegerField(required=True)
    new_password = serializers.CharField(max_length=128, min_length=8, write_only=True, required=True)

    def validate(self, attrs):
        request = self.context.get("request")
        user = request.user
        userpersonalid = attrs.get('userpersonalid')
        new_password = attrs.get('new_password')
        query = 'select userid  from user where userpersonalid = %s'
        with connection.cursor() as cursor:
            cursor.execute(query, [userpersonalid])
        userid = cursor.fetchone()[0]
        cursor.close()

        query = 'select buildingid, areaid  from userlocationinbuildingarea where userid = %s'
        with connection.cursor() as cursor:
            cursor.execute(query, [user.userid])
        data = cursor.fetchone()
        cursor.close()

        # if the user is supporter just can edit the password the usual user inside ourself area and building
        print(user.userroleid.userroleid)
        if user.userroleid.userroleid == 2:
            print(userid)
            query = 'select * from userlocationinbuildingarea where userid =%s and buildingid = %s and areaid =%s'
            with connection.cursor() as cursor:
                cursor.execute(query, [userid, data[0], data[1]])
            data = cursor.fetchone()
            cursor.close()
            print(data)
            if not data:
                raise serializers.ValidationError(
                    'you could not change the user password that not worked in your section')

        password = make_password(new_password)
        query = f"UPDATE user SET userpasword = %s, updateruserid =%s WHERE userpersonalid = %s and userroleid > 1"
        with connection.cursor() as cur:
            cur.execute(query, [password, user.userid, userpersonalid])
        query = f"UPDATE auth_user SET userpasword = %s WHERE userid = %s"
        with connection.cursor() as cursor:
            cursor.execute(query, [password, userid])
        cursor.close()

        log_data = {
            'action': 'change password', 'user-id': userid, 'changer-user-id': user.userid,
            "timestamp": user.last_login.isoformat()
        }
        logger.info(json.dumps(log_data))
        return attrs


class ChangeSubUserInfoSerializer(serializers.Serializer):
    userpersonalid = serializers.IntegerField()
    username = serializers.CharField(required=False)
    userlastname = serializers.CharField(required=False)
    userphonenumber = serializers.CharField(required=False,
                                            validators=[
                                                RegexValidator(
                                                    regex=r'^09(?:[- ]{0,2}\d{3}){3}$',
                                                    message='invalid phone number',
                                                    code='invalid_phone_number'
                                                )
                                            ]
                                            )
    userlandlinephonenumber = serializers.CharField(required=False,
                                                    validators=[
                                                        RegexValidator(
                                                            regex='^0[1-8]{2}[0-9]{8}$',
                                                            message='invalid phone number',
                                                            code='invalid_phone_number',
                                                        )
                                                    ]
                                                    )

    def validate(self, attrs):
        request = self.context.get("request")
        user = request.user
        userpersonalid = attrs.get('userpersonalid')
        username = attrs.get('username')
        userlastname = attrs.get('userlastname')
        userphonenumber = attrs.get('userphonenumber')
        userlandlinephonenumber = attrs.get('userlandlinephonenumber')

        query = 'select userid  from user where userpersonalid = %s'
        with connection.cursor() as cursor:
            cursor.execute(query, [userpersonalid])
        userid = cursor.fetchone()[0]
        cursor.close()

        query = 'select buildingid, areaid  from userlocationinbuildingarea where userid = %s'
        with connection.cursor() as cursor:
            cursor.execute(query, [user.userid])
        data = cursor.fetchone()
        cursor.close()

        if user.userroleid.userroleid == 2:

            query = 'select * from userlocationinbuildingarea where userid =%s and buildingid = %s and areaid =%s'
            with connection.cursor() as cursor:
                cursor.execute(query, [userid, data[0], data[1]])
            data = cursor.fetchone()
            cursor.close()
            if not data:
                raise serializers.ValidationError(
                    'you could not change the user password that not worked in your section')

        update_fields = []
        update_values = []

        if username:
            update_fields.append("username = %s")
            update_values.append(username)
        if userlastname:
            update_fields.append("userlastname = %s")
            update_values.append(userlastname)
        if userphonenumber:
            update_fields.append("userphonenumber = %s")
            update_values.append(userphonenumber)
        if userlandlinephonenumber:
            print(userlandlinephonenumber)
            update_fields.append("userlandlinephonenumber = %s")
            update_values.append(userlandlinephonenumber)

        if update_fields:
            update_query = f"UPDATE user SET {', '.join(update_fields)}, updateruserid = %s WHERE userpersonalid = %s AND userroleid > 1"
            update_values.extend([user.userid, userpersonalid])
            with connection.cursor() as cursor:
                cursor.execute(update_query, update_values)

        log_data = {
            'action': 'change user profile', 'user-id': userid, 'changer-user-id': user.userid,
            "timestamp": user.last_login.isoformat()
        }
        logger.info(json.dumps(log_data))
        return attrs


class ChooseTheSupporter(serializers.Serializer):
    userpersonalid = serializers.IntegerField()
    buildingid = serializers.IntegerField()
    floor = serializers.IntegerField(min_value=1)

    def validate(self, attrs):
        userPersonalId = attrs.get('userpersonalid', '')
        buildingId = attrs.get('buildingid', '')
        # our floor must be the
        floor = attrs.get('floor', '')

        query = 'select userid, userroleid from user where userpersonalid = %s'
        with connection.cursor() as cur:
            cur.execute(query, [userPersonalId])
        userdetail = cur.fetchone()
        cur.close()

        if userdetail:
            if userdetail[1] != 2:
                raise serializers.ValidationError('your entry user must be supporter')
        else:
            raise serializers.ValidationError('user with this personal id not exist!')

        query = 'select * from building where buildingid = %s'
        with connection.cursor() as cur:
            cur.execute(query, [buildingId])
        buildingdetail = cur.fetchone()
        cur.close()

        if buildingdetail is None:
            raise serializers.ValidationError('the building with this id does not exist!')

        if floor <= buildingdetail[7]:
            print(buildingId, floor)
            query = 'SELECT * FROM availablefloortousersupport WHERE buildingid = %s and availablefloor = %s'
            with connection.cursor() as cur:
                cur.execute(query, [buildingId, floor])
            data = cur.fetchone()
            print(data)
            if data:
                raise serializers.ValidationError('This floor already has a supporter')

        if not (0 <= floor <= buildingdetail[7]):
            raise serializers.ValidationError(
                'your entered value so bigger than the available floor or is equal to 0')
        else:

            query = 'insert into availablefloortousersupport (buildingid,usersupportid,availablefloor) VALUES (%s, %s,%s)'
            with connection.cursor() as cur:
                cur.execute(query, [buildingId, userdetail[0], floor])

        return attrs


class DeleteSupporterSerializer(serializers.Serializer):
    userpersonalid = serializers.IntegerField()
    buildingid = serializers.IntegerField()
    floor = serializers.IntegerField(min_value=1)

    def validate(self, attrs):
        userPersonalId = attrs.get('userpersonalid', '')
        buildingId = attrs.get('buildingid', '')
        floor = attrs.get('floor', '')

        query = 'select userid from user where userpersonalid = %s'
        with connection.cursor() as cur:
            cur.execute(query, [userPersonalId])
        userdetail = cur.fetchone()
        cur.close()

        if not userdetail:
            raise serializers.ValidationError('the user not exist')

        query = 'select * from building where buildingid = %s'
        with connection.cursor() as cur:
            cur.execute(query, [buildingId])
        buildingdetail = cur.fetchone()
        cur.close()

        if buildingdetail is None:
            raise serializers.ValidationError('the building with this id does not exist!')

        if not (0 <= floor <= buildingdetail[7]):
            raise serializers.ValidationError('your entered value so bigger than the available floor')

        else:
            query = 'select * from availablefloortousersupport where buildingid = %s and usersupportid= %s and availablefloor = %s'
            with connection.cursor() as cur:
                cur.execute(query, [buildingId, userdetail[0], floor])
            data = cur.fetchone()
            print(data)

            if data:
                query = 'delete from availablefloortousersupport where buildingid = %s and usersupportid= %s and availablefloor = %s'
                with connection.cursor() as cur:
                    cur.execute(query, [buildingId, userdetail[0], floor])
            else:
                raise serializers.ValidationError('we dont have any detail about this in database')

        return attrs


class UpdateSupporterInfoSerializer(serializers.Serializer):
    old_supporterpersonalId = serializers.IntegerField()
    new_supporterpersobalId = serializers.IntegerField()
    buildingid = serializers.IntegerField()
    floor = serializers.IntegerField(min_value=1)

    def validate(self, attrs):
        old_supporterpersonalId = attrs.get('old_supporterpersonalId', '')
        new_supporterpersobalId = attrs.get('new_supporterpersobalId', '')
        buildingId = attrs.get('buildingid', '')
        floor = attrs.get('floor', '')

        query = 'select userid, userroleid from user where userpersonalid = %s'
        with connection.cursor() as cur:
            cur.execute(query, [new_supporterpersobalId])
        userdetail_new = cur.fetchone()
        cur.close()

        if userdetail_new:
            if userdetail_new[1] != 2:
                raise serializers.ValidationError('your entry user must be supporter')
        else:
            raise serializers.ValidationError('user with this user id not exist!')

        query = 'select userid, userroleid from user where userpersonalid = %s'
        with connection.cursor() as cur:
            cur.execute(query, [old_supporterpersonalId])
        userdetailold = cur.fetchone()
        cur.close()

        query = 'select * from availablefloortousersupport where usersupportid = %s and availablefloor= %s and buildingid = %s'
        with connection.cursor() as cur:
            cur.execute(query, [userdetailold[0], floor, buildingId])
            is_exist = cur.fetchone()
            if not is_exist:
                raise serializers.ValidationError('we dont have any detail about this in database')
        cur.close()

        query = 'update availablefloortousersupport set usersupportid = %s where usersupportid =%s and availablefloor = %s and buildingid = %s'
        with connection.cursor() as cur:
            cur.execute(query, [userdetail_new[0], userdetailold[0], floor, buildingId])
        cur.close()

        return attrs


class CreateAreaSerializer(serializers.Serializer):
    areaname = serializers.CharField(min_length=4)

    def validate(self, attrs):
        user = self.context.get("request").user
        areaname = attrs.get('areaname', '')

        query = "INSERT INTO area (areaname, createruserid) VALUES (%s, %s)"
        with connection.cursor() as cur:
            cur.execute(query, [areaname, user.userid])
        return attrs


class UpdateAreaSerializer(serializers.Serializer):
    areaname = serializers.CharField(min_length=4)

    def validate(self, attrs):
        user = self.context.get("request").user
        areaid = self.context.get('areaid')
        areaname = attrs.get('areaname', '')

        query = f"update area set areaname = %s, updateruserid = %s where areaid = %s"
        with connection.cursor() as cur:
            cur.execute(query, [areaname, user.userid, areaid])
        return attrs


class ListAreaSerializer(serializers.ModelSerializer):
    class Meta:
        model = Area
        fields = '__all__'


class CreateBuildingSerializer(serializers.Serializer):
    buildingname = serializers.CharField(min_length=4)
    buildingabbrivationname = serializers.CharField(min_length=2)
    buildingfloorcount = serializers.IntegerField(min_value=1)
    buildingroomcount = serializers.IntegerField(min_value=1)

    def validate(self, attrs):
        user = self.context.get("request").user
        buildingname = attrs.get('buildingname')
        buildingabbrivationname = attrs.get('buildingabbrivationname')
        buildingfloorcount = attrs.get('buildingfloorcount')
        buildingroomcount = attrs.get('buildingroomcount')
        if buildingname and buildingabbrivationname and buildingroomcount and buildingfloorcount:
            query = "INSERT INTO building (buildingname, buildingabbrivationname,buildingfloorcount, buildingroomcount, createruserid) VALUES (%s, %s, %s, %s, %s)"
            with connection.cursor() as cur:
                cur.execute(query,
                            [buildingname, buildingabbrivationname, buildingfloorcount, buildingroomcount, user.userid])
        return attrs


class UpdateBuildingSerializer(serializers.Serializer):
    buildingname = serializers.CharField(min_length=4, allow_null=True, required=False)
    buildingabbrivationname = serializers.CharField(min_length=2, allow_null=True, required=False)
    buildingfloorcount = serializers.IntegerField(min_value=1, allow_null=True, required=False)
    buildingroomcount = serializers.IntegerField(min_value=1, allow_null=True, required=False)

    def validate(self, attrs):
        user = self.context.get("request").user
        buildingid = self.context.get('buildingid')

        print('buildingid')

        buildingname = attrs['buildingname']
        buildingabbrivationname = attrs.get('buildingabbrivationname')
        buildingfloorcount = attrs.get('buildingfloorcount')
        buildingroomcount = attrs.get('buildingroomcount')

        # this if statement check which of them pass and we do the update base on it
        update_fields = []
        update_values = []

        if buildingname:
            update_fields.append("buildingname = %s")
            update_values.append(buildingname)
        if buildingabbrivationname:
            update_fields.append("buildingabbrivationname = %s")
            update_values.append(buildingabbrivationname)
        if buildingfloorcount:
            update_fields.append("buildingfloorcount = %s")
            update_values.append(buildingfloorcount)
        if buildingroomcount:
            update_fields.append("buildingroomcount = %s")
            update_values.append(buildingroomcount)

        if update_fields:
            update_query = f"UPDATE building SET {', '.join(update_fields)}, updateruserid = %s WHERE buildingid = %s"
            update_values.extend([user.userid, buildingid])
            with connection.cursor() as cursor:
                cursor.execute(update_query, update_values)

        return attrs


class ListBuildingSerializer(serializers.ModelSerializer):
    class Meta:
        model = Building
        fields = '__all__'


class ListUserRoleSerializer(serializers.ModelSerializer):
    class Meta:
        model = Userrole
        fields = '__all__'



